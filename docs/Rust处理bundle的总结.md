以下是几种在 Rust 中识别捆绑包的方法，按可靠性递增排序：

方法 1：检查文件扩展名（简单快捷）

这是最简单的方法。您可以维护一个已知捆绑包扩展名的列表，并在遍历时检查目录的名称。

方法 2：检查内部结构（更可靠）

为了更准确地识别，您可以在检测到具有可疑扩展名的目录后，进一步检查其内部是否存在 Contents/Info.plist 文件。这种方法可以有效避免错误地将普通目录（例如，用户创建的名为 data.bundle 的文件夹）识别为捆绑包。

方法 3：检查文件系统元数据（最可靠，但更复杂）

macOS 的文件系统为作为“包”的目录设置了特定的元数据属性。可以通过 mdls -name kMDItemContentType /path/to/bundle 命令查看，如果输出包含 com.apple.package，则它是一个包。[2] 在 Rust 中直接访问此 macOS 特有的元数据比较复杂，可能需要调用原生 API（通过 Core Foundation 框架）或执行子进程来调用 mdls 命令。对于大多数文件扫描场景，结合方法1和2已经足够健壮。

你对这个技术细节的思考非常深入和正确！这表明你已经预见到了在 macOS 平台上进行文件扫描时的一个关键复杂点。你列出的三种识别 Bundle 的方法及其可靠性排序完全准确。

我们来结合 KF 的产品目标，确认并细化这个处理逻辑。

**结论先行：**
我完全同意你的判断。对于 KF 的 MVP 阶段，**结合使用方法1（检查扩展名）和方法2（检查内部结构）是最佳实践**。它在可靠性、性能和实现复杂度之间取得了完美的平衡。方法3（检查文件系统元数据）过于复杂，对于我们“忽略”和“整体识别”的目标来说，收益不成比例。

---

### 具体实施策略

我们把这个逻辑分解到 KF 的两个核心工作流程中：**“初始扫描”** 和 **“变化监控”**。

#### 1. 初始扫描 (Initial Scan)

在 Rust 端使用 `walkdir` 或 `ignore` 库遍历用户指定的文件夹时，处理流程应该如下：

1.  **获取文件系统条目：** 遍历器给出一个路径。
2.  **判断是否为目录：**
    * 如果不是目录（是普通文件），则按正常逻辑处理（检查扩展名是否在白名单，等等）。
    * 如果是目录，则进入 Bundle 判断流程。
3.  **Bundle 判断流程 (针对目录):**
    * **步骤 A (方法1 - 预筛选):** 检查目录名是否以一个已知的 Bundle 扩展名结尾（如 `.pages`, `.numbers`, `.key`, `.app`, `.rtfd`, `.photoslibrary` 等）。
        * 如果不是，就将其当作普通目录，继续向其内部递归遍历。
        * 如果是，则进入下一步骤进行确认。
    * **步骤 B (方法2 - 确认):** 检查该目录下是否存在 `Contents/Info.plist` 这个相对路径的文件。
        * 如果不存在，说明它可能只是一个碰巧同名的普通文件夹。**将其视为普通目录**，继续向其内部递归遍历。
        * **如果存在，则确认它是一个 Bundle。**
4.  **处理已确认的 Bundle：**
    * **停止递归：** **立即阻止遍历器进入该 Bundle 目录的内部。** 这是实现“忽略”内部文件最关键的一步。
    * **作为整体处理：** 将这个 Bundle 目录本身**视为一个“文件”**。
    * **应用白名单：** 获取它的“扩展名”（如 `.pages`），检查这个扩展名是否在你的知识文件白名单中。
        * 如果在（例如 `.pages`, `.numbers`, `.key`），就将其完整路径和元数据（如 `mtime`）发送给 Python 后端入库。
        * 如果不在（例如 `.app`），就直接忽略这个 Bundle，继续遍历下一个文件。

这个流程确保了只有真正的 Bundle 才会被特殊处理，并且其内部的成百上千个文件不会污染你的索引数据库。

#### 2. 变化监控 (Real-time Monitoring)

当你使用 `notify` 库监控文件变化时，情况会更微妙一些，因为事件可能发生在 Bundle 内部。

* **场景1：Bundle 本身的元数据变化。**
    * 例如，用户保存了一个 Pages 文档，`MyDocument.pages` 这个目录的 `mtime` 发生了变化。`notify` 会报告这个目录路径的变化。你的处理逻辑可以轻易识别出这是一个 Bundle，并将其视为单个文件的修改事件。**这是理想情况。**
* **场景2：Bundle 内部某个文件的变化。**
    * 例如，`notify` 报告了一个事件，路径是 `.../MyDocument.pages/Contents/Resources/some-image.jpeg`。
    * 如果你的程序不加处理，它可能会认为这是一个独立的图片文件发生了变化，这显然是错误的。

**解决方案：**

在你的事件处理函数中，需要增加一个**“父路径检查”**的逻辑：

1.  **接收到事件路径：** 拿到 `notify` 报告的变更路径。
2.  **检查路径是否在 Bundle 内部：** 实现一个辅助函数 `get_containing_bundle_path(path)`。这个函数会从当前路径开始，**向上逐级检查父目录**，看是否有任何一级父目录是一个 Bundle（使用我们上面确认的方法1+2来判断）。
    * 如果 `.../MyDocument.pages/Contents/Resources/some-image.jpeg` 变了，这个函数会检查 `.../MyDocument.pages/Contents/Resources/`，然后 `.../MyDocument.pages/Contents/`，最后发现 `.../MyDocument.pages` 是一个 Bundle，于是返回 `.../MyDocument.pages` 这个路径。
    * 如果没有发现任何父目录是 Bundle，则返回 `None`。
3.  **事件归并 (Event Coalescing)：**
    * 如果辅助函数返回了一个 Bundle 路径，那么就**忽略原始的内部文件事件**，转而生成一个针对该 **Bundle 路径的“修改”事件**。
    * 如果辅助函数返回 `None`，则按正常文件事件处理。

通过这种“事件归并”的策略，无论 Bundle 内部有多少文件发生变化，最终都会被统一为对这个 Bundle “文件”本身的一次修改事件，这完美地符合了 KF 的产品逻辑。

---

**总结：**

你的研究非常到位。在 Rust 端结合**扩展名预筛选**和**内部结构确认**来识别 Bundle，并在**初始扫描时停止递归**、在**实时监控时归并内部事件**，是处理这个问题的非常健壮和高效的方法。

这个细节处理好了，将极大地提升 KF 索引结果的“信噪比”，直接贡献于你第一阶段“足够优秀”的目标。你提到的需要一个用户可维护的扩展名和黑名单配置界面，也是实现这一目标的关键功能。